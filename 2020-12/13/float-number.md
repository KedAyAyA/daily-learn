## 浮点数

> 需要前置了解整数、小数二进制转换及存储。IEEE754 单双精度的符号位、指数位、小数位的规定

-   JS 中的 number 都遵循了 IEEE754 的双精度浮点数规范。
-   双精度浮点数 共有64 bit来表示，其中 1位表示符号位（sign），11位表示指数位（exp），52位表示数位(m)
-   公式
    -   V = (-1)^S * 2^(E - 1023) * 1.M
-   一些约定
    -   当 指数位 都为0的时候
        -   m位全部为0 表示数字0
        -   m位不全为0 表示次新正常数，指那些非常接近0的数
    -   当 指数位 为2047的时候
        -   m位全部为0 表示Infinty
        -   m位不全为0 表示NaN
    -   当指数在1 ~ 2046的时候，表示正常数
        -   取中间数 1023 位中位数，因为指数需要有正有负
        -   最小常规正数 E = 1, M = 0 为 2 ^ -1022
        -   最小次常规正数 E = 0, M = (0...[51])1
        -   M位为52位，2 ** 52 = 4503599627370496, 长度为16位，则那么最大可表示的精度为16位

-   一些问题
-   9007199254740992 +(1,2,3,4,5)之后为什么得到的值不按预期？
    -   9007199254740992 为 2 ** 53。而我们的M位最高只有52个bit，当M位全为1时，用科学技术法可以表示为 1.(1*...52) * 2 ^ 52,所表示的数可结算为 2 ^ 52 + ... + 2 ^ 0即 2 ** 53 - 1。当继续加的时候，我们的指数位变成了53，那么最低位的小数位对应的禁止就由 2 ^ 0变成了2 ^ 1，就会造成精度的缺失，这种缺失是奇数的缺失，由于最低位为2 只能按 2 来进位。当然 如果指数为54的话，只能按2^2来进位了。故这也可以解释，为什么9007199254740992 + 1 = 9007199254740992了。我们再观察以下几个例子
        -   9007199254740992 + 1 = 9007199254740992
        -   9007199254740992 + 2 = 9007199254740994
        -   9007199254740992 + 3 = 9007199254740996
        -   9007199254740992 + 4
        = 9007199254740996
        -   9007199254740992 + 5 = 9007199254740996
        可知 当末尾为0的时候，+1则不仅为，末尾为1的时候，+1自动向前进位

-   参考文档
    -   https://juejin.cn/post/6844903680362151950 讲述0.1 + 0.2 !== 0.3的问题
    -   https://www.cnblogs.com/HDK2016/p/10506083.html 讲述浮点数分类及规范的问题